package envrc

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"
	"text/template"
	"time"

	"gopkg.in/yaml.v3"
)

// Options contains configuration for the envrc generator
type Options struct {
	Prefix         string
	ExcludeKeys    []string
	IncludeKeys    []string
	TransformKeys  bool
	Format         string
	TemplateFile   string
	Verbose        bool
	SuppressHeader bool
	SortKeys       bool
}

// Generator handles the generation of .envrc files
type Generator struct {
	options *Options
}

// NewGenerator creates a new envrc generator with the given options
func NewGenerator(options *Options) *Generator {
	if options == nil {
		options = &Options{}
	}
	return &Generator{options: options}
}

// Generate creates the .envrc content from the given secrets
func (g *Generator) Generate(secrets map[string]interface{}) (string, error) {
	// Filter secrets based on include/exclude rules
	filteredSecrets := g.filterSecrets(secrets)

	// Transform keys if requested
	if g.options.TransformKeys {
		filteredSecrets = g.transformKeys(filteredSecrets)
	}

	// Add prefix if specified
	if g.options.Prefix != "" {
		filteredSecrets = g.addPrefix(filteredSecrets)
	}

	// Generate content based on format
	switch g.options.Format {
	case "json":
		return g.generateJSON(filteredSecrets)
	case "yaml":
		return g.generateYAML(filteredSecrets)
	case "envrc":
		fallthrough
	default:
		return g.generateEnvrc(filteredSecrets)
	}
}

// filterSecrets applies include/exclude filters to the secrets
func (g *Generator) filterSecrets(secrets map[string]interface{}) map[string]interface{} {
	result := make(map[string]interface{})

	for key, value := range secrets {
		// If include list is specified, only include matching keys
		if len(g.options.IncludeKeys) > 0 {
			if !g.matchesAny(key, g.options.IncludeKeys) {
				continue
			}
		}

		// Exclude keys that match the exclude list
		if len(g.options.ExcludeKeys) > 0 {
			if g.matchesAny(key, g.options.ExcludeKeys) {
				continue
			}
		}

		result[key] = value
	}

	return result
}

// matchesAny checks if a key matches any pattern in the list
func (g *Generator) matchesAny(key string, patterns []string) bool {
	for _, pattern := range patterns {
		// Support simple wildcard matching
		if matched, _ := regexp.MatchString(strings.ReplaceAll(pattern, "*", ".*"), key); matched {
			return true
		}
		// Also support exact matching
		if key == pattern {
			return true
		}
	}
	return false
}

// transformKeys converts keys to uppercase and replaces hyphens with underscores
func (g *Generator) transformKeys(secrets map[string]interface{}) map[string]interface{} {
	result := make(map[string]interface{})

	for key, value := range secrets {
		transformedKey := strings.ToUpper(strings.ReplaceAll(key, "-", "_"))
		result[transformedKey] = value
	}

	return result
}

// addPrefix adds a prefix to all keys
func (g *Generator) addPrefix(secrets map[string]interface{}) map[string]interface{} {
	result := make(map[string]interface{})

	for key, value := range secrets {
		prefixedKey := g.options.Prefix + key
		result[prefixedKey] = value
	}

	return result
}

// generateEnvrc creates .envrc format content
func (g *Generator) generateEnvrc(secrets map[string]interface{}) (string, error) {
	if g.options.TemplateFile != "" {
		return g.generateFromTemplate(secrets)
	}

	var buf bytes.Buffer

	// Add header comment
	if !g.options.SuppressHeader {
		buf.WriteString("# Generated by vault-envrc-generator\n")
		buf.WriteString(fmt.Sprintf("# Generated at: %s\n", time.Now().Format(time.RFC3339)))
		buf.WriteString("# Source: HashiCorp Vault\n\n")
	}

	// Sort keys for consistent output
	keys := make([]string, 0, len(secrets))
	for key := range secrets {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	// Generate export statements
	for _, key := range keys {
		value := secrets[key]

		// Convert value to string, handling different types
		valueStr := g.formatValue(value)

		// Escape special characters in the value
		escapedValue := g.escapeValue(valueStr)

		buf.WriteString(fmt.Sprintf("export %s=%s\n", key, escapedValue))
	}

	return buf.String(), nil
}

// generateFromTemplate uses a custom template file
func (g *Generator) generateFromTemplate(secrets map[string]interface{}) (string, error) {
	templateContent, err := os.ReadFile(g.options.TemplateFile)
	if err != nil {
		return "", fmt.Errorf("failed to read template file %s: %w", g.options.TemplateFile, err)
	}

	tmpl, err := template.New("envrc").Parse(string(templateContent))
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, secrets); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

// generateJSON creates JSON format output
func (g *Generator) generateJSON(secrets map[string]interface{}) (string, error) {
	// If sorted output is requested, marshal using an ordered representation
	if g.options.SortKeys {
		keys := make([]string, 0, len(secrets))
		for k := range secrets {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		om := orderedMap{keys: keys, m: secrets}
		jsonBytes, err := json.Marshal(om)
		if err != nil {
			return "", fmt.Errorf("failed to marshal ordered JSON: %w", err)
		}
		// MarshalJSON already pretty-prints
		return string(jsonBytes), nil
	}
	jsonBytes, err := json.MarshalIndent(secrets, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal secrets to JSON: %w", err)
	}
	return string(jsonBytes), nil
}

// generateYAML creates YAML format output
func (g *Generator) generateYAML(secrets map[string]interface{}) (string, error) {
	if g.options.SortKeys {
		keys := make([]string, 0, len(secrets))
		for k := range secrets {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		om := orderedMap{keys: keys, m: secrets}
		b, err := yaml.Marshal(om)
		if err != nil {
			return "", fmt.Errorf("failed to marshal ordered YAML: %w", err)
		}
		return string(b), nil
	}
	yamlBytes, err := yaml.Marshal(secrets)
	if err != nil {
		return "", fmt.Errorf("failed to marshal secrets to YAML: %w", err)
	}
	return string(yamlBytes), nil
}

// formatValue converts various types to string representation
func (g *Generator) formatValue(value interface{}) string {
	switch v := value.(type) {
	case string:
		return v
	case int, int32, int64:
		return fmt.Sprintf("%d", v)
	case float32, float64:
		return fmt.Sprintf("%g", v)
	case bool:
		return fmt.Sprintf("%t", v)
	case nil:
		return ""
	default:
		// For complex types, use JSON representation
		if jsonBytes, err := json.Marshal(v); err == nil {
			return string(jsonBytes)
		}
		return fmt.Sprintf("%v", v)
	}
}

// escapeValue properly escapes values for shell environment variables
func (g *Generator) escapeValue(value string) string {
	// If the value contains spaces, quotes, or special characters, wrap in quotes
	if strings.ContainsAny(value, " \t\n\r\"'\\$`") {
		// Escape existing quotes and backslashes
		escaped := strings.ReplaceAll(value, "\\", "\\\\")
		escaped = strings.ReplaceAll(escaped, "\"", "\\\"")
		return fmt.Sprintf("\"%s\"", escaped)
	}
	return value
}

// orderedMap provides deterministic key ordering for JSON and YAML outputs
type orderedMap struct {
	keys []string
	m    map[string]interface{}
}

// MarshalJSON renders a pretty-printed JSON object with sorted keys
func (o orderedMap) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteByte('{')
	for i, k := range o.keys {
		kb, err := json.Marshal(k)
		if err != nil {
			return nil, err
		}
		vb, err := json.Marshal(o.m[k])
		if err != nil {
			return nil, err
		}
		if i == 0 {
			buf.WriteByte('\n')
		} else {
			buf.WriteByte(',')
			buf.WriteByte('\n')
		}
		buf.WriteString("  ")
		buf.Write(kb)
		buf.WriteString(": ")
		buf.Write(vb)
	}
	if len(o.keys) > 0 {
		buf.WriteByte('\n')
	}
	buf.WriteByte('}')
	return buf.Bytes(), nil
}

// MarshalYAML renders a YAML mapping node with keys in order
func (o orderedMap) MarshalYAML() (interface{}, error) {
	node := &yaml.Node{Kind: yaml.MappingNode}
	for _, k := range o.keys {
		keyNode := &yaml.Node{Kind: yaml.ScalarNode, Tag: "!!str", Value: k}
		// Encode value into a node by round-tripping through YAML for correctness
		var valueDoc yaml.Node
		b, err := yaml.Marshal(o.m[k])
		if err != nil {
			return nil, err
		}
		if err := yaml.Unmarshal(b, &valueDoc); err != nil {
			return nil, err
		}
		if len(valueDoc.Content) == 0 {
			valueNode := &yaml.Node{Kind: yaml.ScalarNode, Tag: "!!null", Value: "~"}
			node.Content = append(node.Content, keyNode, valueNode)
			continue
		}
		valueNode := valueDoc.Content[0]
		node.Content = append(node.Content, keyNode, valueNode)
	}
	return node, nil
}
